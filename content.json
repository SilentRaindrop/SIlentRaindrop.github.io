{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Zero","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Java之网络编程","slug":"Java之网络编程","date":"2020-12-08T06:05:10.653Z","updated":"2020-12-12T06:02:31.525Z","comments":true,"path":"2020/12/08/Java之网络编程/","link":"","permalink":"http://yoursite.com/2020/12/08/Java%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Java之网络编程1.网络通信1.1网络编程中有两个主要问题： 如何准确定位网络中的一台或多台主机 找到主机之后如何通信 2.网络编程中的要素 IP和端口号 网络通信协议TCP,UDP 3.万物皆对象2.IPip地址：InetAddress（主要方法） 唯一定位网络上一台计算机 127.0.0.1：本机localhost ip地址的分类 ipv4/ipv6 ipv4:4个字节32位 ipv6:128位 公网(互联网)-私网(局域网) ​ ABCD类地址 InetAddress使用： 1234567891011121314151617181920public class TestInetAddress &#123; public static void main(String[] args) &#123; try &#123; //查询本机地址： System.out.println(InetAddress.getByName(\"127.0.0.1\")); System.out.println(InetAddress.getLocalHost()); System.out.println(InetAddress.getByName(\"localhost\")); //查询网站IP地址 System.out.println(InetAddress.getByName(\"www.baidu.com\")); //常用方法: //getHostName()//获得域名 //getHostAddress()//获得IP &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3.端口端口号表示计算机上一个程序的进程。 不同进程端口号不同，不可冲突！ 0~65535 TCP，UDP：65535*2 tcp:80, udp:80，可以，不同协议下可以使用相同端口号 端口分类 公有端口：0~1023 HTTP：80 HTTPS:443 FTP:21 Telent:23 程序注册端口：1024~49151，分配用户或者程序 Tomcat:8080 Mysql:3306 动态，私有：49152~65535 1231.netstat -ano#查看所有端口2.netstat -ano|findstr \"5900\"#查看指定端口3.tasklist|findstr \"8696\" #查看指定端口的进程 InteSocketAddress类： 12345678import java.net.InetSocketAddress;public class TestInetSocketAddress &#123; public static void main(String[] args) &#123; InetSocketAddress inetSocketAddress = new InetSocketAddress(\"127.0.0.1\", 8080); System.out.println(inetSocketAddress); &#125;&#125; 4.通信协议TCP/IP协议簇： TCP：用户传输协议 UDP：用户数据包协议 IP：网络互联协议 4.1 TCP 客户端 TCP通信的客户端：向服务器发送连接请求，给服务器发送数据，读取服务器回写的数据； 表示客户端的类： java.net.Socket:此类实现客户端套接字，套接字是两台计算机通信的端点，包含IP地址和端口号。 构造方法： Socket(String host,int port) 创建一个流套接字并将其连接到指定主机上的指定端口号。 参数：host是服务器主机的名称/服务器的IP地址；port为服务器的端口号。 成员方法： OutputStream getOutputStream() 返回此套接字的输出流； InputStream getInputStream() 返回此套接字的输入流； void close() 关闭此套接字 实现步骤： 创建一个客户端对象Socket,构造方法绑定服务器端的IP地址和端口号； 使用Scoket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象； 使用获取到的网络字节输出流OutPutStream对象中的方法write,给服务器发送数据； 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象； 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据； 释放资源(Socket) 注意： 客户端和服务器端进行交互，不能使用自己创建的流对象，必须使用Socket中的网络流； 当我们创建客户端对象Socket的时候，就会去请求服务器并通过三次握手建立连接；如果没有启动就会抛出异常，如果启动就可以交互了。 代码实现消息传递（客户端）： 1234567891011121314151617181920public class TCPClientDemo02 &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个客户端对象Socket,构造方法绑定服务器端的IP地址和端口号； Socket socket=new Socket(\"127.0.0.1\",8888); //2.使用Scoket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象； OutputStream os=socket.getOutputStream(); //3.使用获取到的网络字节输出流OutPutStream对象中的方法write,给服务器发送数据； os.write(\"你好，服务器，听得到吗？\".getBytes()); //4.使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象； InputStream is=socket.getInputStream(); //5.使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据； byte[] bytes=new byte[1024]; int len=is.read(bytes); System.out.println(new String(bytes,0,len)); //6.释放资源 socket.close(); &#125;&#125; 服务器 接收客户端的请求，读取客户端发送的数据，给客户端回写数据； 表示服务器的类：java.net.ServerSocket; 构造方法：ServerSocket(int port) 创建绑定到特定端口的服务器套接字； 服务器端必须明确一件事：知道请求来自哪个客户端，所以可以使用accept方法获取到请求的客户端对象Socket; 成员方法：Socket accept() 倾听并接收到此套接字的连接。 服务器的实现步骤： 创建服务器ServerSocket对象和系统要指定的端口号； 使用ServerSocket对象中的方法accept，获取到请求的客户端对象Socket; 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream; 使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据； 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream; 使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据； 释放资源(Socket） 代码实现消息传递（服务器端）： 12345678910111213141516171819202122232425public class TCPServerDemo02 &#123; public static void main(String[] args) throws IOException &#123; //1. 创建服务器ServerSocket对象和系统要指定的端口号； ServerSocket server=new ServerSocket(8888); //2. 使用ServerSocket对象中的方法accept，获取到请求的客户端对象Socket; Socket socket=server.accept(); //3. 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream; InputStream is=socket.getInputStream(); //4. 使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据； byte[] bytes=new byte[1024]; int len=is.read(bytes);//读取is到bytes中并返回读取到的字节数 System.out.println(new String(bytes,0,len)); //5. 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream; OutputStream os=socket.getOutputStream(); //6. 使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据； os.write(\"你好，客户端,已收到\".getBytes()); //7. 释放资源(Socket） socket.close(); server.close(); &#125;&#125; 输出结果： 可见，客户端收到了服务器端回的消息，服务器收到了客户端的消息。 4.2 文件上传 网络字节输出流OutputStream,是自己向对象发送操作所使用的，如发送消息和上传文件； 网络字节输入流InputStream,是自己读取对方的操作所使用的，如读取对象的消息和文件等。 文件上传客户端代码： 1234567891011121314151617181920212223242526272829303132333435363738394041/** 文件上传案例的客户端：读取本地文件，上传到客户端，读取客户端回写的数据* 数据源：D:\\Program Files (x86)\\JavaFiles\\kid.jpg* 目的地：服务器* */public class TCPFileClient &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个本地字节输入流对象，构造方法绑定要读取的数据源 FileInputStream file=new FileInputStream(\"D:\\\\Program Files (x86)\\\\JavaFiles\\\\kid.jpg\"); //2.创建一个客户端Socket对象，构造方法中绑定服务器的IP地址和端口号 Socket socket=new Socket(\"127.0.0.1\",8888); //3.使用socket中的方法getOutputStream()，获取网络字节输出流OutputStream对象 OutputStream os=socket.getOutputStream(); //4.使用本地字节输入流FileInputStream对象中的方法read,读取本地文件 int len=0; byte[] bytes=new byte[1024]; /*注意！！！file.read(bytes)读取本地文件，结束标记是读取到-1结束，但是while不会读取到-1，此时read()方法将阻塞，并且不会把结束标记学给服务器！因此后面的代码将不会执行！*/ /*解决：上传完文件，给服务器写一个结束标记 * void shutdownOutput()禁用此套接字的输出流 * 对于TCP套接字，任何以前写入的数据都将被发送，并且后跟tcp连接的正常终止序列 * */ while((len=file.read(bytes))!=-1)&#123; //5.使用网络字节输出流OutputStream中的方法write，把读取到的文件上传到服务器 os.write(bytes,0,len); &#125; socket.shutdownOutput(); //6.使用Socket中的方法getInputStream，获取网络字节输入流InputStream对象 InputStream is=socket.getInputStream(); //7.使用网络字节输入流InputStream对象中的read方法读取服务器回写的数据 while((len=is.read(bytes))!=-1)&#123; System.out.println(new String(bytes,0,len)); &#125; //8.释放资源 file.close(); socket.close(); &#125;&#125; 文件上传服务器端代码： 1234567891011121314151617181920212223242526272829303132333435363738/** 文件上传案例的服务器端：读取客户端上传的文件，保存到服务器的硬盘，给客户端回写“上传成功”* 数据源:客户端上传的文件* 目的地：服务器硬盘：D:\\learn\\1-3-Java语言高级\\07-网络编程* */public class TCPFileServer &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个服务器ServerSocket对象，和系统要指定的端口号 ServerSocket server=new ServerSocket(8888); //2.使用ServerSocket中的方法accept，获取到请求的客户端socket对象 Socket socket=server.accept(); //3.使用scoket中的getInputStream方法，获取到网络字节输入流InputStream对象 InputStream is=socket.getInputStream(); //4.判断服务器本地硬盘文件夹是否存在，没有则创建 File file=new File(\"D:\\\\learn\\\\1-3-Java语言高级\\\\07-网络编程\"); if(!file.exists()) file.mkdirs(); //5.创建一个本地字节输出流FileOutputStream对象，构造方法绑定要输出的目的地 FileOutputStream fos=new FileOutputStream(file+\"\\\\kid.jpg\"); //6.使用网络字节输入流对象InputStream中的read方法，读取客户端上传的文件 byte[] bytes=new byte[1024]; int len=0; /*注意，while循环读取不到-1，因此read方法阻塞，后面的代码不会执行 */ while ((len=is.read(bytes))!=-1)&#123; //7.使用本地字节输出流FileOutputStream对象的write方法，把读取到的文件输出到服务器硬盘 fos.write(bytes,0,len); &#125; //8.使用socket对象的方法getOutputStream获取网络字节输出流对象 //9.使用网络字节输出流对象OutputStream，给客户端回写“上传成功” OutputStream os=socket.getOutputStream(); os.write(\"上传成功\".getBytes()); //10.关闭资源 fos.close(); socket.close(); server.close(); &#125;&#125; 关于文件上传的几点优化： 上传的文件名可以不用固定，这样每次上传相同文件都可以成功。 可以让服务器一直处于监听模式，而不是没上传一次就关闭； 当多个客户端同时上传时效率将大大降低，为此可以用多线程上传，即将主要代码放入thread中的run方法体内。","categories":[],"tags":[]},{"title":"Java学习之Maven","slug":"Java学习之Maven","date":"2020-12-07T02:24:03.350Z","updated":"2020-12-07T07:57:21.611Z","comments":true,"path":"2020/12/07/Java学习之Maven/","link":"","permalink":"http://yoursite.com/2020/12/07/Java%E5%AD%A6%E4%B9%A0%E4%B9%8BMaven/","excerpt":"","text":"Java学习之Maven1.基本介绍Maven是一个Java项目的管理和构建工具： Maven使用pom.xml定义项目内容，并使用预设的目录结构； 在Maven中声明一个依赖项可以自动下载并导入classpath； Maven使用groupId，artifactId和version唯一定位一个依赖。 其中，groupId类似于Java的包名，通常是公司或组织名称，artifactId类似于Java的类名，通常是项目名称，再加上version，一个Maven工程就是由groupId，artifactId和version作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。 2.依赖管理 Maven解决了依赖管理问题，例如我们的项目依赖abc这个jar包，而abc又依赖xyz这个jar包，当我们声明了abc的依赖时，Maven自动把xyz都加入了我们的项目依赖，不需要我们自己去研究abc是否需要依赖abc。 Maven定义了几种依赖关系，分别是compile、test、runtime和provided： Maven维护了一个中央仓库（repo1.maven.org），所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地。除了可以从Maven的中央仓库下载外，还可以从Maven的镜像仓库下载。如果访问Maven的中央仓库非常慢，我们可以选择一个速度较快的Maven的镜像仓库。Maven镜像仓库定期从中央仓库同步.中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录下进入.m2目录，创建一个settings.xml配置文件，内容如下： 1234567891011&lt;settings&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;!-- 国内推荐阿里云的Maven镜像 --&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 如果我们要引用一个第三方组件，比如okhttp，如何确切地获得它的groupId、artifactId和version？方法是通过search.maven.org搜索关键字，找到对应的组件后，直接复制. 3.构建流程Maven通过lifecycle、phase和goal来提供标准的构建流程。 lifecycle相当于Java的package，它包含一个或多个phase； phase相当于Java的class，它包含一个或多个goal； goal相当于class的method，它其实才是真正干活的。","categories":[],"tags":[]},{"title":"Java多线程学习","slug":"Java多线程学习","date":"2020-12-05T02:33:03.885Z","updated":"2020-12-06T11:26:59.458Z","comments":true,"path":"2020/12/05/Java多线程学习/","link":"","permalink":"http://yoursite.com/2020/12/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Java多线程学习1、创建线程方式1.自定义线程类继承Thread类，重写run()方法，调用start开启线程； (不建议使用：避免oop单继承局限性) 123456789101112131415161718public class starttest &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t=new myThread(); t.start(); System.out.println(\"thread end\"); &#125;&#125;class myThread extends Thread &#123; @Override public void run() &#123; int n = 0; while (!isInterrupted()) &#123; n++; System.out.println(n + \"Hello !!\"); &#125; &#125;&#125; 2.实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start； （推荐使用：避免OOP单继承局限性，灵活方便，方便同一个对象被多个线程使用） 12345678910111213141516171819public class start02 implements Runnable&#123; @Override public void run() &#123; for(int i=0;i&lt;200;i++)&#123; System.out.println(\"第二种方法创建线程。\"+i); &#125; &#125; public static void main(String[] args) &#123; //创建runnable接口的实现类对象 start02 s=new start02(); //创建线程对象，通过线程对象来开启我们的线程，代理 //Thread thread =new Thread(s); // thread.start(); new Thread(s).start(); for(int i=0;i&lt;1000;i++) System.out.println(\"主方法\"+i); &#125;&#125; 3.实现callable接口，具体步骤如下： ​ 1.实现Callable接口，需要返回值类型 ​ 2.重写call方法，需要抛出异常 ​ 3.创建目标对象 ​ 4.创建执行服务：ExecutorService ser=Executors.newFixedThreadPool(1); ​ 5.提交执行:Future result=ser.submit(t); ​ 6.获取结果:boolean r1=result.get(); ​ 7.关闭服务:ser.shutdownNow(). 1234567891011121314151617181920212223242526272829public class start03 implements Callable&lt;Boolean&gt; &#123; @Override public Boolean call() &#123; for(int i=0;i&lt;200;i++)&#123; System.out.println(\"第三种方法创建线程。\"+i); &#125; return true; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; start03 s1=new start03(); start03 s2=new start03(); start03 s3=new start03(); //创建执行服务 ExecutorService ser= Executors.newFixedThreadPool(3); //提交执行 Future&lt;Boolean&gt; f1=ser.submit(s1); Future&lt;Boolean&gt; f2=ser.submit(s2); Future&lt;Boolean&gt; f3=ser.submit(s3); //获取结果 boolean r1=f1.get(); boolean r2=f2.get(); boolean r3=f3.get(); //关闭服务 ser.shutdownNow(); &#125;&#125; callable的好处：1.可以抛出异常 ​ 2.可以定义返回值 *注意：1.线程开启不一定立即执行，一般交替执行，（即不是按照声明方法的次序执行的）由CPU调度。 2.静态代理1.真实对象和代理对象都要实现同一个接口； 2.代理对象要代理真实角色。 好处：​ 代理对象可以做很多真实对象做不到的事情； ​ 真实对象可以专注于做某一件事情。 123456789101112131415161718192021222324252627282930313233343536interface Marry&#123; public void HappyMarry();&#125;class Person implements Marry&#123; @Override public void HappyMarry() &#123; System.out.println(\"她今天结婚，很开心\"); &#125;&#125;class wedCompany implements Marry&#123; private Marry target;//要代理的真实角色 public wedCompany(Marry target)&#123; this.target=target; &#125; @Override public void HappyMarry()&#123; before(); this.target.HappyMarry();//真实对象 after(); &#125; private void before() &#123; System.out.println(\"结婚前，布置现场。\"); &#125; private void after() &#123; System.out.println(\"结婚后，好好生活。\"); &#125;&#125;public class staticProxy &#123; public static void main(String[] args) &#123; Person she=new Person(); wedCompany wed=new wedCompany(she); wed.HappyMarry(); &#125;&#125; 在这里，wedCompany就是静态代理，she为真实对象。 3.Lamda表达式1.好处：避免匿名内部类定义过多；让代码看起来更简洁；去掉一堆没意义的代码，保留核心逻辑 2.函数式接口：定义：任何接口如果只包含一个抽象方法，那么它就是一个函数式接口。 public interface Runnable{ ​ public abstract void run(); } 对于函数式接口，我们可以使用lambda表达式来创建该接口对象。 基本语法： 实例对象=()-&gt;{代码体}； 直接省略了要继承的接口和覆写方法，括号()中可以定义参数。参数类型和括号也可以省略，当代码只有一行时，你甚至可以省略花括号{}。多参数时也可以省略参数类型，要去掉就都去掉。 4.停止线程 不推荐使用JDK提供的stop()等方法； 推荐线程自己停下来； 建议使用一个标志位进行终止变量，当flag=false，则终止线程运行。 public class threadStop implements Runnable{ private boolean flag=true; @Override public void run() { int i=0; while (flag)//当标志位为真时执行线程 { System.out.println(\"thread keep run\"+i++); } } //自定义一个方法停止线程——通过修改标志位 public void myStop(){ flag=false; } public static void main(String[] args) { threadStop threadStop=new threadStop(); new Thread(threadStop).start(); for(int i=0;i&lt;1000;i++){ System.out.println(\"main run\"+i); if(i==900) { threadStop.myStop(); System.out.println(\"副线程停止\"); } } } } &lt;!--￼4--&gt; 7.线程强制执行-Join 合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞 可以想象成插队。 12345678910111213141516171819public class joinTest implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 300; i++) &#123; System.out.println(\"县长来啦，鹅城太平啦!\"+i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; joinTest j=new joinTest(); Thread t=new Thread(j); t.start(); for (int i = 0; i &lt; 200; i++) &#123; if(i==199) t.join();//新线程插队，强制执行完 System.out.println(\"黄四郎来了。\"+i); &#125; &#125;&#125; 8.线程状态1234567891011121314151617181920212223242526272829public class stateTest &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread=new Thread(()-&gt;&#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"////////////\"); &#125;); //观察状态 Thread.State state=thread.getState(); System.out.println(state); //观察启动后 thread.start(); state=thread.getState(); System.out.println(state); //只要线程不停止就一直输出状态 while(state!=Thread.State.TERMINATED) &#123; Thread.sleep(200); state=thread.getState();//要更新线程状态 System.out.println(state);//输出状态 &#125; &#125;&#125; 9.线程优先级 Java提供一个线程调度器来监控程序中启动偶进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。 线程优先级用数字表示，范围从1-10 Thread.MIN_PRIORITY=1; Thread.MAX_PRIORITY=10; Thread.NORM_PRIORITY=5; 使用setPriority(int)设置优先级，getPriority()获取优先级。 优先级低只是意味着获得调度的概率低，并不是优先级低就不会调用了，这都是看CPU的调度，也有可能优先级低的比优先级高的先执行。 12345678910111213141516171819202122232425262728293031323334class myPriority implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"——&gt;\"+Thread.currentThread().getPriority()); &#125;&#125;public class priorityTest &#123; public static void main(String[] args) &#123; myPriority my=new myPriority(); Thread t1=new Thread(my,\"t1\"); Thread t2=new Thread(my,\"t2\"); Thread t3=new Thread(my,\"t3\"); Thread t4=new Thread(my,\"t4\"); Thread t5=new Thread(my,\"t5\"); Thread t6=new Thread(my,\"t6\"); t1.setPriority(1); t1.start(); t2.setPriority(3); t2.start(); t3.setPriority(Thread.MAX_PRIORITY); t3.start(); t4.setPriority(9); t4.start(); t5.setPriority(2); t5.start(); t6.setPriority(6); t6.start(); &#125;&#125; 运行结果为： t3——&gt;10t4——&gt;9t6——&gt;6t2——&gt;3t1——&gt;1t5——&gt;2 可见，并不是优先级高的就一定先运行，t5在t1之后运行。 10.守护（daemon）线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不必等待守护线程执行完毕 如：后台记录操作日志，监控内存，垃圾回收等 123456789101112131415161718192021222324252627282930public class daemonTest &#123; public static void main(String[] args) &#123; You you =new You(); Angel angel=new Angel(); Thread thread=new Thread(angel); thread.setDaemon(true);//默认为false thread.start(); new Thread(you).start(); &#125;&#125;class You implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 500; i++) &#123; System.out.println(\"每一天你都开心的活着。\"+i); &#125; System.out.println(\"===========good bye,world.===========\"); &#125;&#125;class Angel implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"天使守护你。\"+i); &#125; System.out.println(\"==========天使降临，你看到了吗？===========\"); &#125;&#125; 我们将进程angel设置为守护进程后，虚拟机不会等待守护线程结束： 可以看到daemon线程没有打印完就结束了。 11.进程同步1.并发问题1：123456789101112131415161718192021222324public class problem01 implements Runnable&#123; private int number=10; @Override public void run() &#123; while(true)&#123; if(number&lt;=0) break; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\" 拿到了第\"+number--+\"张票\"); &#125; &#125; public static void main(String[] args) &#123; problem01 p=new problem01(); new Thread(p,\"小明\").start(); new Thread(p,\"黄牛\").start(); new Thread(p,\"小红\").start(); &#125;&#125; 输出结果为： 小明 拿到了第10张票黄牛 拿到了第9张票小红 拿到了第8张票小红 拿到了第7张票小明 拿到了第6张票黄牛 拿到了第7张票黄牛 拿到了第5张票小明 拿到了第5张票小红 拿到了第5张票黄牛 拿到了第4张票小红 拿到了第3张票小明 拿到了第4张票黄牛 拿到了第2张票小明 拿到了第1张票小红 拿到了第0张票黄牛 拿到了第-1张票 可见线程发生了并发性错误，取出了-1张票。 2.并发问题2：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class unsafeWithdraw &#123; public static void main(String[] args) &#123; Account account=new Account(100,\"结婚基金\"); Withdraw you=new Withdraw(account,50,\"你\"); Withdraw she=new Withdraw(account,100,\"她\"); you.start(); she.start(); &#125;&#125;//账户class Account&#123; int base;//余额 String name;//卡名 public Account(int base, String name) &#123; this.base = base; this.name = name; &#125;&#125;//银行：模拟取款class Withdraw extends Thread&#123; Account account; int drawMoney; int nowMoney; public Withdraw(Account account, int drawMoney, String name) &#123; super(name); this.account = account; this.drawMoney = drawMoney; &#125; @Override public void run() &#123; //判断有没有钱 if(account.base-drawMoney&lt;0)&#123; System.out.println(\"钱不够了。\"); return; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //卡内余额=余额-你取的钱 account.base=account.base-drawMoney; //你手里的钱 nowMoney=nowMoney+drawMoney; System.out.println(account.name+\"余额为：\"+account.base); System.out.println(this.getName()+\"手里的钱：\"+nowMoney); &#125;&#125; 输出结果为： 结婚基金余额为：0她手里的钱：100结婚基金余额为：-50你手里的钱：50 基金不能为负数。发生了并发性问题。 3.加锁机制针对方法提出一种加锁机制，使用的关键字是synchronized. synchronized方法 同步方法：public synchronized void method(int args){} synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦实行就独占该锁，知道该方法返回才释放锁，后面被阻塞的进程才能获得这个锁，从而执行。 缺陷：若将一个大的方法加锁将会影响效率。 synchronized块 同步块：synchronized(Obj){} Obj称为同步监视器 ​ Obj可以是任何对象，但是推荐使用共享资源作为同步监视器； ​ 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this,就是这个对象本身，或者是class。 4.解决方案： 针对问题1，在买票的核心方法中用synchronized修饰即可，此时买票就需要排队了，这里用的是同步方法。 针对问题2，将取款核心代码用synchronized块包住即可，这里用的是同步块。 12.Lock锁 显式定义同步锁对象来实现同步，同步锁使用Lock对象充当； 锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象； 在实现线程安全的控制中，比较常用的是ReentrantLock，它拥有与synchronized相同的并发性和内存语义，可以显式加锁，释放锁。 12345678910111213class A&#123; private final ReentrantLock lock=new ReentrantLock();` public void m()&#123; lock.lock(); try&#123; //保证线程安全的代码；` &#125;finally&#123; lock.unlock();//如果代码有异常，要将unlock()写入finally语句块 &#125; &#125;&#125; 13.管程法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class TestPC &#123; public static void main(String[] args) &#123; SynContainer container=new SynContainer(); new Productor(container).start(); new Consumer(container).start(); &#125;&#125;//生产者class Productor extends Thread&#123; SynContainer container; public Productor(SynContainer container)&#123; this.container=container; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; container.push(new Chicken(i)); System.out.println(\"生产了\"+i+\"只鸡\"); &#125; &#125;&#125;//消费者class Consumer extends Thread&#123; SynContainer container; public Consumer(SynContainer container)&#123; this.container=container; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"消费了——&gt;\"+container.pop().id+\"只鸡\"); &#125; &#125;&#125;//产品class Chicken&#123; int id; public Chicken(int id) &#123; this.id = id; &#125;&#125;//缓冲区class SynContainer&#123; //需要一个容器大小 Chicken[] chickens=new Chicken[10]; //容器计数器 int count=0; //生产者放入产品 public synchronized void push(Chicken chicken)&#123; //如果容器满了，阻塞自己，不再生产，而是等待消费者消费 if(count==chickens.length) &#123; try &#123; this.wait();//生产等待 &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; //如果没有满，需要丢入产品 chickens[count]=chicken; count++; //可以通知消费者消费了 this.notifyAll(); &#125; //消费者消费产品 public synchronized Chicken pop()&#123; //判断能否消费 if(count==0)&#123; //等待生产者生产，消费者等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果可以消费 count--; Chicken chicken=chickens[count]; //吃完了，通知生产者生产 this.notifyAll(); return chicken; &#125;&#125; 如果缓冲区满了，生产者阻塞，等待消费者消费；如果缓冲区为空，消费者阻塞，等待生产者生产。 14.信号灯法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//测试生产者消费者问题2：信号灯法，用标志位解决public class testPC2 &#123; public static void main(String[] args) &#123; TV tv=new TV(); new Player(tv).start(); new Watcher(tv).start(); &#125;&#125;//生产者，演员class Player extends Thread&#123; TV tv; public Player(TV tv) &#123; this.tv = tv; &#125; @Override public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; if(i%2==0) this.tv.play(\"进击的巨人。\"); else this.tv.play(\"刺客五六七。\"); &#125; &#125;&#125;//消费者：观众class Watcher extends Thread&#123; TV tv; public Watcher(TV tv) &#123; this.tv = tv; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; tv.watch(); &#125; &#125;&#125;//产品：节目class TV&#123; //假设逻辑：演员表演，观众等待；观众观看，演员等待 String voice;//表演的节目 boolean flag=true; //表演 public synchronized void play(String voice)&#123; if(!flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"演员表演了\"+voice); this.notifyAll(); this.voice=voice; this.flag=!this.flag; &#125; //观看 public synchronized void watch()&#123; if(flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"观看了：\"+voice); //通知演员表演 this.notifyAll(); this.flag=!this.flag; &#125;&#125; 15.线程池 背景：经常创建和销毁，使用量特别大得资源，比如并发情况下得线程，对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建和销毁，实现重复利用，类似公共交通工具。 好处： 提高响应速度 降低资源消耗 便于线程管理 主要属性： corePoolSize:核心池得大小 maximumPoolSize:最大线程数 keepAliveTime:线程没有任务时最多保持多长时间会终止。 相关API：ExecutorService和Executors ExecutorService:真正得线程池接口，常见子类ThreadPoolExecutor void execute(Runnable command):执行任务/命令，没有返回值，一般用来执行Runnable Future submit(Callable task):执行任务，有返回值，一般又来执行Callable void shutdown():关闭连接池 Executors:工具类、线程池的工厂类，用于创建并返回不同类型的线程池 1234567891011121314151617181920212223public class ThreadPool &#123; public static void main(String[] args) &#123; //创建服务 //newFixedThreadPool参数为线程池大小 ExecutorService service= Executors.newFixedThreadPool(10); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //关闭链接 service.shutdownNow(); &#125;&#125;class MyThread implements Runnable&#123; @Override public void run()&#123; System.out.println(Thread.currentThread().getName()); &#125;&#125;","categories":[],"tags":[]},{"title":"关于使用clion时遇到的问题","slug":"关于使用clion时遇到的问题","date":"2020-11-18T08:59:49.869Z","updated":"2020-11-18T09:06:09.606Z","comments":true,"path":"2020/11/18/关于使用clion时遇到的问题/","link":"","permalink":"http://yoursite.com/2020/11/18/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8clion%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"一开始觉得用clion写c的话会比较好，于是就下载了clion尝尝鲜，结果运行第一个程序就出问题了：显示Error:CreateProcess error=216, 该版本的 %1 与您运行的 Windows 版本不兼容。在网上找了很多解决方案，其中一种是：Tools-CMake-Reset Cache and Reload Project,我试了一下果然可行，但是下一个项目又不行了。然后又找了另一个方法：运行cmd启动命令行，输入：for %1 in (%windir%\\system32*.dll) do regsvr32.exe /s %1 ，等待运行完毕后重启，至此问题解决。","categories":[],"tags":[]},{"title":"计算机网络知识点提炼","slug":"计算机网络知识点提炼","date":"2020-03-16T08:25:09.051Z","updated":"2020-05-12T07:21:59.689Z","comments":true,"path":"2020/03/16/计算机网络知识点提炼/","link":"","permalink":"http://yoursite.com/2020/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8F%90%E7%82%BC/","excerpt":"","text":"计算机网络自顶向下第一章 TCP/IP协议体系的认知TCI/IP自顶向下：应用层 传输层 网际层 网络接口层 OSI参考模型自顶向下：应用层 表达层 会话层 传输层 网络层 数据链路层 物理层 综合 自顶向下： 应用层 传输层 网络层 数据链路层 物理层 第二章 应用层###DNS协议 第三章第四章第五章第六章","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"o我的第一篇博客","date":"2020-02-17T08:44:00.000Z","updated":"2020-02-18T08:46:09.681Z","comments":true,"path":"2020/02/17/o我的第一篇博客/","link":"","permalink":"http://yoursite.com/2020/02/17/o%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"这是我的第一篇博客，主要讲述我是如何搭建个人博客的。 首先需要感谢的是B站的UP主CodeSheep，羊哥，羊哥的视频很详细，基本上这个视频完成了我搭建博客的大部分步骤，接着要感谢的是segmentfault上的博主Zacklearning，因为他的分享使我得以在此编辑我自己的博文。 接下来开始说明一下我在我的电脑上是如何搭建博客的： 环境：win10 工具：node.js,hexo,git 步骤： 1.网上下载node.js并安装，网站是www.nodejs.org，记得点击左边的下载按钮，安装过程一直默认就好了； 2.打开命令提示符，windows可以直接输入npm install -g hexo-cli，mac需要在前面额外加入sudo,否则会出现权限问题。如果嫌弃直接这样下载太慢的话，我们可以借助国内的淘宝镜像：npm install -g cnpm –registry=https://registry.npm.taobao.org 然后输入cnmp install -g hexo-cli.到此hexo框架已经完成； 3.下面使用hexo正式搭建博客：在C盘Administrator文件夹下建立blog文件夹，以后关于博客的文件以及操纵都在此文件夹下完成。 下面在命令行进入这个文件夹，输入：hexo init，（这个初始化过程需要一点时间，因为在写之前已经完成，所以我无法放图。）完成后系统提示Start blogging Hexo!这样就安装完成了。 4.输入hexo s，启动博客，我们在浏览器输入localhost:4000,就可以在本地看到自己的博客网站了。该博客默认有一篇Hello world的博客。start服务基本上可以在我们预览时使用。现在我们ctrl+c关闭博客。回到blog目录，我们输入hexo n +博客名称就可以添加自己的博客了，博客存放在blog下的source文件夹下。至于写博客之后再说。 5.下面把博客部署到github上去：我们先登录自己的github，添加一个新的仓库，注意仓库名称要和自己的用户名一致。比如我的用户名是SilentRaindrop,那么我把仓库名设置为：SilentRaindrop.github.io. 6.下面在blog目录下安装一个git部署的插件，输入cnpm install –save hexo-deployer-git,这样系统就直接安装了。下面我们打开blog目录下的_config.yml文件，在最低端的#Deployment下的deploy进行配置：输入type:gitrepo:这里是github里新建仓库的URLbranch:master这样文件就修改完成了。下面部署到远端，输入：hexo d.系统会提示输入github账号密码，输入即可。系统提示成功这样就算是成功了。我们来到刚刚建好的github仓库，就可以看到多了很多文件，拿出URL中的域名，这就是我们的博客地址了，浏览器输入，等一会就可以看到自己的博客了。这样远端就部署成功了。 7.主题什么的可以自己去找了，接下来说一下如何编辑自己的博客：这里要用到一个插件admin,输入npm install –save hexo-admin，启动服务器，即可在localhost:4000/admin/中编辑博文了。另外，在windows中部署的话还需要修改一下_config.yml文件，在末尾加上admin:deployCommand ‘hexo-publish.bat’,并在blog目录下新建文件hexo-publish.bat，内容为hexo g -d。这样在admin中编辑的博文就可以发布了。 终： 至此，使用hexo搭建静态博客框架基本算是完成了。","categories":[{"name":"exercise","slug":"exercise","permalink":"http://yoursite.com/categories/exercise/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}],"author":"Zero"},{"title":"Hello World","slug":"hello-world","date":"2020-02-17T08:32:18.370Z","updated":"2020-02-17T08:32:18.370Z","comments":true,"path":"2020/02/17/hello-world/","link":"","permalink":"http://yoursite.com/2020/02/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}